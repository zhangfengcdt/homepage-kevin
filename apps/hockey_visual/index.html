<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hockey Play Animator - Draw Your Moves!</title>
    <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>üèí</text></svg>">
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="styles.css">
</head>


<body>
<div class="container">
    <div class="flex items-center justify-center mb-4">
        <img src="kevin_logo.png" alt="Kevin's Logo" class="h-12 w-auto mr-4">
        <h1 class="mb-0">üèí Hockey Play Animator - Draw Epic Moves!</h1>
    </div>
    <p class="text-gray-600 mb-6">Create awesome hockey plays with AI! Just describe your strategy and watch the magic happen ‚ú®</p>

    <!-- Strategy Input Section -->
    <div class="mb-6 p-4 bg-gray-50 rounded-lg">
        <h3 class="text-lg font-semibold text-gray-700 mb-3">ü§ñ AI Play Maker</h3>
        
        <!-- API Key Toggle -->
        <div class="mb-3">
            <button id="toggleApiKeySection" class="flex items-center gap-2 text-sm text-gray-600 hover:text-gray-800 transition-colors">
                <svg id="apiKeyToggleIcon" class="w-4 h-4 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
                </svg>
                <span id="apiKeyToggleText">Show API Key Settings</span>
            </button>
        </div>
        
        <!-- API Key Input -->
        <div id="apiKeySection" class="mb-4 hidden">
            <label for="apiKeyInput" class="block text-sm font-medium text-gray-700 mb-2">OpenAI API Key:</label>
            <div class="flex gap-2">
                <input 
                    type="password" 
                    id="apiKeyInput" 
                    placeholder="sk-..."
                    class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500 font-mono text-sm"
                />
                <button 
                    id="toggleApiKeyBtn" 
                    class="px-3 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors"
                    title="Show/Hide API Key"
                >
                    <svg id="eyeIcon" class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                    </svg>
                </button>
            </div>
            <p class="text-xs text-gray-500 mt-1">Your API key is stored locally and never sent to our servers. Get one from <a href="https://platform.openai.com/api-keys" target="_blank" class="text-blue-600 hover:underline">OpenAI</a>.</p>
        </div>
        
        <!-- Strategy Input -->
        <p class="text-sm text-gray-600 mb-3">Tell the AI what play you want to run and it'll draw it for you! üéÆ</p>
        <div class="flex gap-3">
            <input 
                type="text" 
                id="strategyInput" 
                placeholder="e.g., Execute a power play formation with emphasis on quick puck movement"
                value="Can you show a strategy that the A team moving right after the initial positions?"
                class="flex-1 px-4 py-2 border border-gray-300 rounded-lg focus:outline-none focus:ring-2 focus:ring-blue-500"
            />
            <button 
                id="generateStrategyBtn" 
                class="px-6 py-2 bg-purple-600 text-white rounded-lg hover:bg-purple-700 transition-colors flex items-center gap-2"
            >
                <svg class="w-5 h-5" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13 10V3L4 14h7v7l9-11h-7z"></path>
                </svg>
                Generate with AI (kevin)
            </button>
        </div>
        <div id="aiStatus" class="mt-3 text-sm text-gray-600 hidden"></div>
    </div>

    <!-- Toggle for showing/hiding position maps -->
    <div class="mb-4 flex items-center justify-between">
        <button id="toggleMapsBtn" class="flex items-center gap-2 px-4 py-2 bg-gray-200 text-gray-700 rounded-lg hover:bg-gray-300 transition-colors">
            <svg id="toggleIcon" class="w-5 h-5 transform transition-transform" fill="none" stroke="currentColor" viewBox="0 0 24 24">
                <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5l7 7-7 7"></path>
            </svg>
            <span id="toggleText">Show Position Maps</span>
        </button>
        <span class="text-sm text-gray-500">View/edit the text-based position maps</span>
    </div>

    <div id="positionMapsContainer" class="grid grid-cols-1 md:grid-cols-2 gap-4 mb-4 hidden">
        <div>
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-lg font-semibold text-gray-700">Start Positions</h3>
                <button id="pasteStartBtn" class="px-3 py-1 text-sm bg-green-500 text-white rounded hover:bg-green-600 transition-colors">
                    Paste
                </button>
            </div>
            <textarea id="startGridInput" class="code-editor" spellcheck="false"></textarea>
        </div>
        <div>
            <div class="flex justify-between items-center mb-2">
                <h3 class="text-lg font-semibold text-gray-700">End Positions</h3>
                <button id="pasteEndBtn" class="px-3 py-1 text-sm bg-green-500 text-white rounded hover:bg-green-600 transition-colors">
                    Paste
                </button>
            </div>
            <textarea id="endGridInput" class="code-editor" spellcheck="false"></textarea>
        </div>
    </div>

    <button id="generateGridBtn">Generate Movement Visualization</button>
    <div id="rinkGridContainer"></div>

    <div class="legend">
        <h2 class="text-lg font-semibold mb-4 text-gray-800">Legend:</h2>
        <div class="legend-item">
            <div class="legend-color-box team-a-player"></div>
            <span class="legend-text">Team A Players (Red circles)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box team-b-player"></div>
            <span class="legend-text">Team B Players (Blue circles)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box goalie"></div>
            <span class="legend-text">Goalies (Yellow circles)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box puck puck-legend"></div>
            <span class="legend-text">Hockey Puck (Small Black circle)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box square" style="background-color: #f8fafc; border: 1px solid #cbd5e0;"></div>
            <span class="legend-text">Goal (Light Gray/White squares)</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box square" style="background-color: #a0aec0; border-radius: 5px;"></div>
            <span class="legend-text">Rink Line Marker (Gray square for '>')</span>
        </div>
        <div class="legend-item">
            <div class="legend-color-box square" style="background-color: #e0f2f7; border: 1px dashed #cbd5e0;"></div>
            <span class="legend-text">Empty Rink Space (Light Blue/Ice color)</span>
        </div>
    </div>
    
    <!-- Generated Strategy Analysis (moved to bottom) -->
    <div id="strategyDetails" class="mt-6 p-4 bg-white rounded-lg border border-gray-200 hidden">
        <h4 class="text-lg font-semibold text-gray-700 mb-3">Generated Strategy Analysis:</h4>
        <div id="strategyContent" class="text-sm text-gray-600 space-y-3"></div>
    </div>
</div>

<script>
    document.addEventListener('DOMContentLoaded', () => {
        const generateGridBtn = document.getElementById('generateGridBtn');
        const rinkGridContainer = document.getElementById('rinkGridContainer');
        const startGridInput = document.getElementById('startGridInput');
        const endGridInput = document.getElementById('endGridInput');
        const pasteStartBtn = document.getElementById('pasteStartBtn');
        const pasteEndBtn = document.getElementById('pasteEndBtn');
        const generateStrategyBtn = document.getElementById('generateStrategyBtn');
        const strategyInput = document.getElementById('strategyInput');
        const aiStatus = document.getElementById('aiStatus');
        const strategyDetails = document.getElementById('strategyDetails');
        const strategyContent = document.getElementById('strategyContent');
        const apiKeyInput = document.getElementById('apiKeyInput');
        const toggleApiKeyBtn = document.getElementById('toggleApiKeyBtn');
        const toggleMapsBtn = document.getElementById('toggleMapsBtn');
        const positionMapsContainer = document.getElementById('positionMapsContainer');
        const toggleIcon = document.getElementById('toggleIcon');
        const toggleText = document.getElementById('toggleText');
        const toggleApiKeySection = document.getElementById('toggleApiKeySection');
        const apiKeySection = document.getElementById('apiKeySection');
        const apiKeyToggleIcon = document.getElementById('apiKeyToggleIcon');
        const apiKeyToggleText = document.getElementById('apiKeyToggleText');

        generateGridBtn.addEventListener('click', renderMovementVisualization);
        generateStrategyBtn.addEventListener('click', generateStrategyWithAI);
        
        // Toggle API key section visibility
        toggleApiKeySection.addEventListener('click', () => {
            const isHidden = apiKeySection.classList.contains('hidden');
            
            if (isHidden) {
                apiKeySection.classList.remove('hidden');
                apiKeyToggleIcon.classList.add('rotate-90');
                apiKeyToggleText.textContent = 'Hide API Key Settings';
            } else {
                apiKeySection.classList.add('hidden');
                apiKeyToggleIcon.classList.remove('rotate-90');
                apiKeyToggleText.textContent = 'Show API Key Settings';
            }
        });
        
        // Toggle position maps visibility
        toggleMapsBtn.addEventListener('click', () => {
            const isHidden = positionMapsContainer.classList.contains('hidden');
            
            if (isHidden) {
                positionMapsContainer.classList.remove('hidden');
                toggleIcon.classList.add('rotate-90');
                toggleText.textContent = 'Hide Position Maps';
            } else {
                positionMapsContainer.classList.add('hidden');
                toggleIcon.classList.remove('rotate-90');
                toggleText.textContent = 'Show Position Maps';
            }
        });
        
        // Toggle API key visibility
        toggleApiKeyBtn.addEventListener('click', () => {
            const isPassword = apiKeyInput.type === 'password';
            apiKeyInput.type = isPassword ? 'text' : 'password';
            
            // Update eye icon
            const eyeIcon = document.getElementById('eyeIcon');
            if (isPassword) {
                eyeIcon.innerHTML = `
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M13.875 18.825A10.05 10.05 0 0112 19c-4.478 0-8.268-2.943-9.543-7a9.97 9.97 0 011.563-3.029m5.858.908a3 3 0 114.243 4.243M9.878 9.878l4.242 4.242M9.88 9.88l-3.29-3.29m7.532 7.532l3.29 3.29M3 3l3.59 3.59m0 0A9.953 9.953 0 0112 5c4.478 0 8.268 2.943 9.543 7a10.025 10.025 0 01-4.132 5.411m0 0L21 21"></path>
                `;
            } else {
                eyeIcon.innerHTML = `
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M15 12a3 3 0 11-6 0 3 3 0 016 0z"></path>
                    <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M2.458 12C3.732 7.943 7.523 5 12 5c4.478 0 8.268 2.943 9.542 7-1.274 4.057-5.064 7-9.542 7-4.477 0-8.268-2.943-9.542-7z"></path>
                `;
            }
        });
        
        // Load API key from localStorage if available
        const savedApiKey = localStorage.getItem('openai_api_key');
        if (savedApiKey) {
            apiKeyInput.value = savedApiKey;
        }
        
        // Save API key to localStorage when it changes
        apiKeyInput.addEventListener('change', () => {
            localStorage.setItem('openai_api_key', apiKeyInput.value);
        });
        
        // Add paste functionality
        pasteStartBtn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                startGridInput.value = text;
                renderMovementVisualization();
            } catch (err) {
                alert('Failed to paste from clipboard. Please make sure you have given clipboard permissions.');
            }
        });
        
        pasteEndBtn.addEventListener('click', async () => {
            try {
                const text = await navigator.clipboard.readText();
                endGridInput.value = text;
                renderMovementVisualization();
            } catch (err) {
                alert('Failed to paste from clipboard. Please make sure you have given clipboard permissions.');
            }
        });
        
        // Don't automatically render on page load since textareas are empty by default
        // renderMovementVisualization();

        async function generateStrategyWithAI() {
            console.log('Starting generateStrategyWithAI...');
            
            const strategy = strategyInput.value.trim();
            const apiKey = apiKeyInput.value.trim();
            
            console.log('Strategy:', strategy);
            console.log('API Key length:', apiKey.length);
            
            if (!strategy) {
                alert('Please enter a strategy description');
                return;
            }
            
            if (!apiKey) {
                alert('Please enter your OpenAI API key');
                apiKeyInput.focus();
                return;
            }

            // Show loading status with fancy animation
            aiStatus.classList.remove('hidden');
            aiStatus.innerHTML = `
                <div class="ai-loading">
                    <span class="ai-brain">üß†</span>
                    <span>AI is analyzing your strategy</span>
                    <div class="ai-loading-dots">
                        <div class="ai-loading-dot"></div>
                        <div class="ai-loading-dot"></div>
                        <div class="ai-loading-dot"></div>
                    </div>
                </div>
                <div class="ai-progress-bar">
                    <div class="ai-progress-fill"></div>
                </div>
            `;
            generateStrategyBtn.disabled = true;
            strategyDetails.classList.add('hidden');
            
            console.log('UI updated, preparing API call...');

            const systemPrompt = `You are a professional ice hockey coach who is skilled in planning game strategies and mapping them on the whiteboard. 

The user will propose a specific hockey player strategy and describe key points of that strategy. 

Please create a strategy map by following the following steps:

- Begin by clarifying the purpose, core objectives, and overall vision for the game. 
- Analyze both teams' strong and weak points.
- Use your knowledge and experience in playing and coaching ice hockey to pick a good strategy.
- Describe how each player on your team would implement the strategy, including their current positions and the positions they need to move to. 
- Predict the opponent's current and future positions.
- Draw the start and end position maps on the board using the following format of mapping the ice rinks. 

Output format:

Should be TEXT format, including the following paragraphs on one level:
- Purpose: TEXT
- CoreObjectives: TEXT
- Vision: TEXT
- TeamAnalysis: TEXT
- StrategyChoice: LIST of TEXT
- OpponentReactions: LIST of TEXT
- Player Implementation: LIST of TEXT
- start: TEXT (using the following position 2D map based on text art format)
- end: TEXT (using the following position 2D map based on text art format)

start position:
+----------------------------------------------------------------------+
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  >  .  A4 .  .  .  .  .  .  .  .  .  .  .  B4 .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  A1 .  .  .  B1 .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  G  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  G . |
|.  G  AG .  .  .  .  .  .  .  . A2  P  B2 .  .  .  .  .  .  .  BG G . |
|.  G  .  .  .  .  .  .  .  .  .  .  >  .  .  .  .  .  .  .  .  .  G . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  A3 .  .  .  B3 .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  A5 .  .  .  .  .  .  .  .  .  .  .  B5 .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
|.  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  .  . . |
+----------------------------------------------------------------------+

Explanation of Symbols:
  A1-A5: Attacking team players (A4, A5 are defense men)
  B1-B5: Defending team players
  G : Goal
  AG: Attacking Goalie
  BG: Defending Goalie
  P : Puck
  . : Empty ice
  +, -, |: Rink boundary
  >: referee

Rules:
- each strategy should output two and only two position maps (start and end) as the above format;
- you need to move the puck as well for each strategy.
- The position should have all grid points' status:
- each map should have the same number of x and y cells, and they should be aligned.
- the end position map should be different than the start position map (at least one player should move).
- both teams should move!!!

`;

            try {
                console.log('Preparing API request...');
                
                const requestBody = {
                    model: 'gpt-4o-mini',
                    messages: [
                        { role: 'system', content: systemPrompt },
                        { role: 'user', content: strategy }
                    ],
                    temperature: 0.7,
                    max_tokens: 4000
                };
                
                console.log('Request body:', JSON.stringify(requestBody, null, 2));
                console.log('Making API call to OpenAI...');
                
                const response = await fetch('https://api.openai.com/v1/chat/completions', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify(requestBody)
                });
                
                console.log('API call completed, status:', response.status);

                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({}));
                    console.error('API Error:', errorData);
                    throw new Error(`API request failed: ${response.status} ${response.statusText}`);
                }

                console.log('Parsing response JSON...');
                const data = await response.json();
                console.log('Response data:', data);
                
                if (!data.choices || !data.choices[0] || !data.choices[0].message) {
                    throw new Error('Invalid response structure from OpenAI');
                }
                
                const aiResponse = data.choices[0].message.content;
                console.log('AI Response:', aiResponse); // Debug log

                // Parse the AI response - look for the grid patterns more flexibly
                console.log('Looking for start/end patterns...');
                
                // Find all grid patterns in the response
                const gridPattern = /\+[-\s]+\+[\s\S]*?\+[-\s]+\+/g;
                const allGrids = aiResponse.match(gridPattern);
                console.log('Found', allGrids ? allGrids.length : 0, 'grid patterns');
                
                // Log each grid found for debugging
                if (allGrids) {
                    allGrids.forEach((grid, index) => {
                        console.log(`Grid ${index + 1} first line:`, grid.split('\n')[0]);
                        console.log(`Grid ${index + 1} position in response:`, aiResponse.indexOf(grid));
                    });
                }
                
                let startGrid = null;
                let endGrid = null;
                
                // Method 1: Split by common separators between start and end
                const separatorPatterns = [
                    /\nend\s*(?:positions?)?:?\s*\n/i,
                    /\n\s*end\s+/i,
                    /\nend:/i,
                    /\n\n.*?end.*?\n/i
                ];
                
                let splitIndex = -1;
                let separatorFound = null;
                
                for (const pattern of separatorPatterns) {
                    const match = aiResponse.match(pattern);
                    if (match) {
                        splitIndex = aiResponse.indexOf(match[0]);
                        separatorFound = match[0];
                        console.log('Found separator:', separatorFound.replace(/\n/g, '\\n'));
                        break;
                    }
                }
                
                if (splitIndex > 0 && allGrids && allGrids.length >= 2) {
                    // Find grids before and after the separator
                    for (const grid of allGrids) {
                        const gridIndex = aiResponse.indexOf(grid);
                        if (gridIndex < splitIndex && !startGrid) {
                            startGrid = grid;
                            console.log('Found start grid before separator at index:', gridIndex);
                        } else if (gridIndex > splitIndex && !endGrid) {
                            endGrid = grid;
                            console.log('Found end grid after separator at index:', gridIndex);
                        }
                    }
                }
                
                // Method 2: If we have exactly 2 grids and they're different, use them
                if ((!startGrid || !endGrid) && allGrids && allGrids.length === 2) {
                    if (allGrids[0] !== allGrids[1]) {
                        console.log('Using simple method - exactly 2 different grids found');
                        startGrid = allGrids[0];
                        endGrid = allGrids[1];
                    }
                }
                
                // Method 3: Look for the word "start" before first grid and "end" before second grid
                if ((!startGrid || !endGrid) && allGrids && allGrids.length >= 2) {
                    const beforeFirst = aiResponse.substring(0, aiResponse.indexOf(allGrids[0]));
                    const beforeSecond = aiResponse.substring(aiResponse.indexOf(allGrids[0]) + allGrids[0].length, 
                                                             aiResponse.indexOf(allGrids[allGrids.length - 1]));
                    
                    if (beforeFirst.toLowerCase().includes('start') && beforeSecond.toLowerCase().includes('end')) {
                        console.log('Using keyword detection method');
                        startGrid = allGrids[0];
                        endGrid = allGrids[allGrids.length - 1];
                    }
                }
                
                // Method 4: Last resort - use first and last grid if they're different
                if ((!startGrid || !endGrid) && allGrids && allGrids.length >= 2) {
                    const firstGrid = allGrids[0];
                    const lastGrid = allGrids[allGrids.length - 1];
                    
                    if (firstGrid !== lastGrid) {
                        console.log('Using last resort method - first and last grids are different');
                        startGrid = firstGrid;
                        endGrid = lastGrid;
                    } else {
                        console.error('ERROR: All grids found are identical!');
                        // Try to find if there's a different grid in the middle
                        for (let i = 1; i < allGrids.length - 1; i++) {
                            if (allGrids[i] !== firstGrid) {
                                console.log('Found different grid at position', i + 1);
                                endGrid = allGrids[i];
                                break;
                            }
                        }
                    }
                }
                
                console.log('Start grid found:', !!startGrid);
                console.log('End grid found:', !!endGrid);
                console.log('Start grid preview:', startGrid ? startGrid.substring(0, 100) + '...' : 'null');
                console.log('End grid preview:', endGrid ? endGrid.substring(0, 100) + '...' : 'null');

                if (startGrid && endGrid) {
                    // Check if grids are identical
                    if (startGrid === endGrid) {
                        console.warn('WARNING: Start and end grids are identical!');
                        console.log('Full AI Response to debug:', aiResponse);
                        
                        // Try one more time to find different grids
                        if (allGrids && allGrids.length > 1) {
                            console.log('Attempting to find different grids in the response...');
                            for (let i = 0; i < allGrids.length; i++) {
                                for (let j = i + 1; j < allGrids.length; j++) {
                                    if (allGrids[i] !== allGrids[j]) {
                                        console.log(`Found different grids at positions ${i+1} and ${j+1}`);
                                        startGrid = allGrids[i];
                                        endGrid = allGrids[j];
                                        break;
                                    }
                                }
                                if (startGrid !== endGrid) break;
                            }
                        }
                    }
                    
                    // Visual comparison
                    console.log('=== GRID COMPARISON ===');
                    console.log('Grids are identical?', startGrid === endGrid);
                    if (startGrid !== endGrid) {
                        const startLines = startGrid.split('\n');
                        const endLines = endGrid.split('\n');
                        let differences = 0;
                        for (let i = 0; i < Math.min(startLines.length, endLines.length); i++) {
                            if (startLines[i] !== endLines[i]) {
                                differences++;
                                console.log(`Line ${i+1} differs:`);
                                console.log('  Start:', startLines[i]);
                                console.log('  End:  ', endLines[i]);
                            }
                        }
                        console.log(`Total differences: ${differences} lines`);
                    }

                    // Update the input fields
                    startGridInput.value = startGrid;
                    endGridInput.value = endGrid;

                    // Show strategy details
                    strategyContent.innerHTML = '';
                    
                    // Parse and display strategy analysis
                    const sections = [
                        { key: 'Purpose', label: 'Purpose' },
                        { key: 'CoreObjectives', label: 'Core Objectives' },
                        { key: 'Vision', label: 'Vision' },
                        { key: 'TeamAnalysis', label: 'Team Analysis' },
                        { key: 'StrategyChoice', label: 'Strategy Choice' },
                        { key: 'OpponentReactions', label: 'Opponent Reactions' },
                        { key: 'Player Implementation', label: 'Player Implementation' }
                    ];

                    sections.forEach(section => {
                        const regex = new RegExp(`${section.key}:\\s*([\\s\\S]*?)(?=\\w+:|start:|$)`, 'i');
                        const match = aiResponse.match(regex);
                        if (match) {
                            const div = document.createElement('div');
                            div.innerHTML = `<strong>${section.label}:</strong> ${match[1].trim()}`;
                            strategyContent.appendChild(div);
                        }
                    });

                    strategyDetails.classList.remove('hidden');

                    // Automatically render the visualization
                    renderMovementVisualization();

                    aiStatus.innerHTML = '‚úÖ Strategy generated successfully!';
                } else {
                    console.error('Failed to parse grids from AI response');
                    throw new Error('Could not parse AI response - no valid grid patterns found');
                }
            } catch (error) {
                console.error('Caught error:', error);
                console.error('Error stack:', error.stack);
                
                // More detailed error messages
                if (error.name === 'TypeError' && error.message.includes('fetch')) {
                    aiStatus.innerHTML = '‚ùå Network error. Check your internet connection and try again.';
                } else if (error.message.includes('API request failed')) {
                    aiStatus.innerHTML = '‚ùå API request failed. Please check your API key and ensure it has access to the model.';
                } else if (error.message.includes('parse')) {
                    aiStatus.innerHTML = '‚ùå Could not parse AI response. The AI may not have returned the grids in the expected format.';
                } else if (error.message.includes('Invalid response structure')) {
                    aiStatus.innerHTML = '‚ùå Invalid response from OpenAI. Please check your API key.';
                } else {
                    aiStatus.innerHTML = `‚ùå Error: ${error.message}`;
                }
            } finally {
                console.log('Cleaning up...');
                generateStrategyBtn.disabled = false;
            }
        }

        function parseGridString(gridString) {
            const lines = gridString.split('\n').map(line => line.trim()).filter(line => line.length > 0 && !line.startsWith('+'));
            const parsedGrid = [];

            for (const line of lines) {
                const row = [];
                const content = line.substring(1, line.length - 1).trim();
                const cells = content.match(/(\S+\s*|\s+)/g);
                if (cells) {
                    for (const cell of cells) {
                        const trimmedCell = cell.trim();
                        if (trimmedCell !== '') {
                            row.push(trimmedCell);
                        } else if (cell.length >= 2 && trimmedCell === '') {
                            row.push('.');
                        }
                    }
                }
                if (row.length > 0) {
                    parsedGrid.push(row);
                }
            }
            return parsedGrid;
        }

        function renderMovementVisualization() {
            const startGridString = startGridInput.value.trim();
            const endGridString = endGridInput.value.trim();
            
            // Clear the container
            rinkGridContainer.innerHTML = '';
            
            // Don't show error if inputs are empty
            if (!startGridString || !endGridString) {
                return;
            }
            
            const startGrid = parseGridString(startGridString);
            const endGrid = parseGridString(endGridString);

            if (startGrid.length === 0 || endGrid.length === 0) {
                rinkGridContainer.textContent = 'Failed to parse grid data. Please check the format of your position maps.';
                return;
            }

            // Create movement visualization only
            const movementContainer = document.createElement('div');
            movementContainer.className = 'text-center';
            
            const movementTitle = document.createElement('h3');
            movementTitle.className = 'text-lg font-semibold mb-4 text-gray-700';
            movementTitle.textContent = 'Player Movements';
            movementContainer.appendChild(movementTitle);
            
            const movementGridContainer = document.createElement('div');
            movementGridContainer.style.display = 'grid';
            movementGridContainer.style.gridTemplateColumns = `repeat(${startGrid[0].length}, 1fr)`;
            movementGridContainer.className = 'border-2 border-gray-700 bg-gray-100 p-2 rounded-lg shadow-lg inline-block grid-container';
            renderMovementGrid(startGrid, endGrid, movementGridContainer);
            movementContainer.appendChild(movementGridContainer);
            
            rinkGridContainer.appendChild(movementContainer);
        }
        
        function renderGrid(grid, container) {
            grid.forEach(row => {
                row.forEach(cellContent => {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');

                    if (cellContent.match(/^A[1-5]$/)) {
                        cell.classList.add('team-a-player');
                        cell.textContent = cellContent;
                    } else if (cellContent.match(/^B[1-5]$/)) {
                        cell.classList.add('team-b-player');
                        cell.textContent = cellContent;
                    } else if (cellContent === 'AG' || cellContent === 'BG') {
                        cell.classList.add('goalie');
                        cell.textContent = cellContent;
                    } else if (cellContent === 'P') {
                        cell.classList.add('puck');
                    } else if (cellContent === 'G') {
                        cell.classList.add('goal');
                        cell.textContent = cellContent;
                    } else if (cellContent === '>') {
                        cell.classList.add('rink-line');
                        cell.textContent = cellContent;
                    } else {
                        cell.textContent = cellContent === '.' ? '' : cellContent;
                    }
                    container.appendChild(cell);
                });
            });
        }
        
        function renderMovementGrid(startGrid, endGrid, container) {
            const playerMovements = findPlayerMovements(startGrid, endGrid);
            
            // Render the basic grid first (showing start positions)
            startGrid.forEach((row, rowIndex) => {
                row.forEach((cellContent, colIndex) => {
                    const cell = document.createElement('div');
                    cell.classList.add('grid-cell');
                    cell.setAttribute('data-row', rowIndex);
                    cell.setAttribute('data-col', colIndex);

                    if (cellContent.match(/^A[1-5]$/)) {
                        cell.classList.add('team-a-player');
                        cell.textContent = cellContent;
                    } else if (cellContent.match(/^B[1-5]$/)) {
                        cell.classList.add('team-b-player');
                        cell.textContent = cellContent;
                    } else if (cellContent === 'AG' || cellContent === 'BG') {
                        cell.classList.add('goalie');
                        cell.textContent = cellContent;
                    } else if (cellContent === 'P') {
                        cell.classList.add('puck');
                    } else if (cellContent === 'G') {
                        cell.classList.add('goal');
                        cell.textContent = cellContent;
                    } else if (cellContent === '>') {
                        cell.classList.add('rink-line');
                        cell.textContent = cellContent;
                    } else {
                        cell.textContent = cellContent === '.' ? '' : cellContent;
                    }
                    container.appendChild(cell);
                });
            });
            
            // Add movement arrows after grid is rendered
            setTimeout(() => {
                playerMovements.forEach(movement => {
                    if (movement.startRow !== movement.endRow || movement.startCol !== movement.endCol) {
                        const startCell = container.querySelector(`[data-row="${movement.startRow}"][data-col="${movement.startCol}"]`);
                        const endCell = container.querySelector(`[data-row="${movement.endRow}"][data-col="${movement.endCol}"]`);
                        
                        if (startCell && endCell) {
                            const startRect = startCell.getBoundingClientRect();
                            const endRect = endCell.getBoundingClientRect();
                            const containerRect = container.getBoundingClientRect();
                            
                            // Calculate centers relative to container
                            const startX = startRect.left - containerRect.left + startRect.width / 2;
                            const startY = startRect.top - containerRect.top + startRect.height / 2;
                            const endX = endRect.left - containerRect.left + endRect.width / 2;
                            const endY = endRect.top - containerRect.top + endRect.height / 2;
                            
                            // Calculate arrow properties
                            const deltaX = endX - startX;
                            const deltaY = endY - startY;
                            const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);
                            const angle = Math.atan2(deltaY, deltaX) * 180 / Math.PI;
                            
                            const arrow = document.createElement('div');
                            arrow.className = 'movement-arrow';
                            arrow.style.position = 'absolute';
                            arrow.style.left = `${startX}px`;
                            arrow.style.top = `${startY}px`;
                            arrow.style.width = `${distance}px`;
                            arrow.style.height = '3px';
                            arrow.style.backgroundColor = movement.player.match(/^A/) ? '#ef4444' : '#3b82f6';
                            arrow.style.transformOrigin = '0 50%';
                            arrow.style.transform = `rotate(${angle}deg)`;
                            arrow.style.pointerEvents = 'none';
                            arrow.style.zIndex = '10';
                            
                            // Add arrowhead
                            const arrowhead = document.createElement('div');
                            arrowhead.style.position = 'absolute';
                            arrowhead.style.right = '-8px';
                            arrowhead.style.top = '-5px';
                            arrowhead.style.width = '0';
                            arrowhead.style.height = '0';
                            arrowhead.style.borderLeft = `8px solid ${movement.player.match(/^A/) ? '#ef4444' : '#3b82f6'}`;
                            arrowhead.style.borderTop = '5px solid transparent';
                            arrowhead.style.borderBottom = '5px solid transparent';
                            
                            arrow.appendChild(arrowhead);
                            container.appendChild(arrow);
                        }
                    }
                });
            }, 50);
        }
        
        function findPlayerMovements(startGrid, endGrid) {
            const movements = [];
            const startPositions = {};
            const endPositions = {};
            
            // Find all player positions in start grid
            startGrid.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell.match(/^[AB][1-5G]$/) || cell === 'P') {
                        startPositions[cell] = { row: rowIndex, col: colIndex };
                    }
                });
            });
            
            // Find all player positions in end grid
            endGrid.forEach((row, rowIndex) => {
                row.forEach((cell, colIndex) => {
                    if (cell.match(/^[AB][1-5G]$/) || cell === 'P') {
                        endPositions[cell] = { row: rowIndex, col: colIndex };
                    }
                });
            });
            
            // Calculate movements
            Object.keys(startPositions).forEach(player => {
                if (endPositions[player]) {
                    movements.push({
                        player: player,
                        startRow: startPositions[player].row,
                        startCol: startPositions[player].col,
                        endRow: endPositions[player].row,
                        endCol: endPositions[player].col
                    });
                }
            });
            
            return movements;
        }
    });
</script>
</body>
</html>